Object类：1.类Object是类层此结构的根，每个类都使用Object作为超（父）类；
因此自己定义的类，也可以使用Object中的方法；
（1）equal：对于基本类型来说比较的是值；对于引用数据类型来说是比较的两个对象的地址值
（2）toString：如果没有重写toString方法，那么打印的就是对象的地址值（默认）【因为子类中没有重写该方法，
就会去找父类的toString()方法】。

注意：多态的弊端：无法使用子类特有的属性和方法
解决：可以使用向下转型（强转）

2.null是不能调用方法的，会抛出空指针异常
3.总结：Objects对象工具类，

Data类：
1.System.currentTimeMillis()获取当前系统的毫秒值（从1970年1月1日0.0.0开始）
Date()；空参数构造方法
Data(Long date)：传递毫秒值，吧毫秒值转换成Data日期
Data.getTime();把日期转换成毫秒值

2.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");按照指定的模式，输出日期
String text = simpleDateFormat.format(date);

按照指定的格式解析日期
SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒");
        Date date2 = sdf.parse("2020年08月10日 11时39分56秒");
        System.out.println(date2);

4.总结：Calendar类
A.创建对象方式
Calendar c= Calendar.newlnstance();
B成员方法
int get(int n); 获取指定日历字段信息
void set(int n, int value); 将指定日历字段设置为指定的值 c.set(Calendar.YEAR,1997);
void add(int n, int value);将指定日历字段增加或减少为指定的值


======================================
======================================
======================================
======================================
System类
1.public static long currentTimeMills(); 返回以毫秒为单位的当前时间，可以用来计算程序执行的时间
2.public static void arraycopy(Object src, int srcPos, Objcet dest, int destPos, int length);
将src中的数组从第srcPos号位置开始，赋值到dest数组中的destPos位置，复制的个数为length;

StringBuilder类
1.String类字符串常量；他们的值在创建之后不能更改。字符串的底层是一个被final修饰的数组，不能改变，是一个
常量。【给一个已有字符串"abcd"第二次赋值成"abcedl"，不是在原内存地址上修改数据，而是重新指向一个新对象，新地址】
2.StringBuilder类 字符串缓冲区，可以提高字符串的操作效率(看成一个长度可变的字符串)，底层也是一个数组，但是
是没有被final修饰，可以改变长度
StringBuilder在内存中始终只有一个数组，占用空间少，效率高，如果超出了StringBuilder的容量，会自动扩容。
3.StringBuilder的构造方法
StringBuilder bu1 = new StringBuffer();
StringBuilder bu2 = new StringBuffer("aaaa");
4.(1)public StringBuilder append(); 添加任意类型数据的字符串形式，并返回当前对象自身。自身就会发生改变
，直接调用即可。
链式编程：bu1.append().append().append().append();
(2)String--->StringBuilder, StringBuilder(String str)构造一个字符串生成器，并初始化指定字符串中的内容；
StringBuilder--->String public String toString();将当前的StringBuilder对象转化成String对象。
bu.toString();

StringBuffer 和 StringBuilder 的 3 个区别:
*线程安全，StringBuilder：线程不安全。因为StringBuffer的所有公开方法都是+synchronized+修饰的，
而+StringBuilder+并没有+synchronized+修饰。
*StringBuffer+每次获取+toString+都会直接使用缓存区的+toStringCache+值来构造一个字符串。
+而+StringBuilder+则每次都需要复制一次字符数组，再构造一个字符串。
*StringBuilder+的性能要远大于+StringBuffer
所以，StringBuffer+适用于用在多线程操作同一个+StringBuffer+的场景，如果是单线程场合+StringBuilder+更适合。


java传递的参数：总结就是基本数据类型传递的是形参，形参不影响实参；引用数据类型传递的是地址，形参在方法内被改变，
实参也会改变，若在方法内实例化了同名对象，即产生了新的地址，对这个同名对象的改变，由于地址不一样，所以不影响原来的对象



包装类：
1.基本数据类型的数据，使用非常方便，但是没有对应方法进行操作这些数据，所以我们可以使用一个类，把基本数据
类型的数据包装起来，这个类叫做包装类，再包装类中可以定义一些方法，用来操作基本类型的数据
2.装箱：从基本数据类型转换成对应的包装类对象
拆箱：从包装类对象转换为对应的基本数据类型
Integer i = new Integer(4);
Integer ii = Integer.valueof(4);
int num = i.intVaule();

自动装箱：Integer in = 1；
自动拆箱：in = in + 3；

3.字符串转换成基本类型：使用包装类中的静态方法parseXx(String s) 例如Integer.parseInt(String s)
基本类型转换成字符串类型：1.直接用“+”连接字符串
2.toString(int t) 返回一个表示指定的整数的String对象 Integer.toString(100)；
3.使用String类中的静态方法，static String valueof(int i)返回int参数的字符串表示形式。
String.valueOf(100);

======================================
======================================
======================================
======================================
Collection 集合
1.集合：集合是java中提供的一种容器，可以用来存储多个数据
集合和数组的区别：（1）数组的长度是固定的，集合的长度是可变的
（2）数组中存储的是同一类型的元素，可以存储基本数据类型值，集合存储的都是对象，而且对象的类型可以不
一致，在开发中一般当多个对象的时候，使用集合进行存储。
2.Collection List   ArrayList   LinkedList    Vector
                    Set  HashSet   LinkedHashSet    TreeSet
Collection add() remove() clear() contains()(是否包含某个元素) isEmpty() size() toArray()(集合转换成数组)<定义在最顶层中，子类均继承>

Iterator接口 （Iterator是一个接口，需要实现类）
1（1）.Boolean hasNext() 如果仍有元素则返回true
（2）E next()返回迭代的下个元素
Collection接口中有一个方法，iterator(),这个方法返回的就是迭代器的实现类对象
Iterator<E> iterator() Iterator
2.当Iterator.next()每执行一次，Iterator变会自加1

3.增强for循环
        for(String c : coll){//集合或数组的数据类型 变量名 ： 集合名/数组名
            System.out.print(c);// 变量名
        }

泛型
泛型是一种未知的数据类型，
1.ArrayList集合定义的时候，不知道集合中都会存什么类型的数据，所以类型使用泛型
public class ArrayList<E>{
           public E get(int index)
}

2.含有泛型的方法：
public class Demo01Generic {
    public <E> void method(E e){
        System.out.println(e);
    }
}

3.含有泛型的接口：
格式：public interface GenericInterface<I> {}
实现方法：（1）在定义实现类时就，指定了泛型的数据类型：public class GenericInterfaceImpl implements GenericInterface<String>{}
（2）接口是什么泛型，实现类就是什么泛型，相当于定义了一个泛型类，【在创建对象的时候确定泛型的数据类型】
public class GenericInterfaceImpl2<I> implements GenericInterface<I>{}
GenericInterfaceImpl2<Integer> gi2 = new GenericInterfaceImpl2<>();

4.泛型通配符：?:代表任意的数据类型
使用方式：（1）不能创建对象使用，（2）【只能作为方法的参数使用】
public static void print(ArrayList<?> list)   用来接收

======================================
======================================
======================================
======================================
数据结构：
1.List : set() get() remove() add()
ArrayList 底层是一个数组 查询快增删慢
（2）.LinkedList 底层是一个哈希表（数组+链表/红黑树） 查询慢增删快 特有的getLast() addFirst()
2 .Set: 不允许重复的元素 没有索引，不能使用普通for遍历（用迭代器遍历，或是增强for）
HashSet：继承自Set，还有两个特点，存储元素与取出元素顺序不一致， 底层是一个哈希表（查询速度很快）
Object 中的一个方法 int hasCode();返回对象的哈希码值 （哈希值时十进制的数，由系统给出，就是对象的逻辑地址）

注意：Set元素不能重复，如果要存储自定义的元素，要重写hasCode(),和equals方法
LinkedHashSet特点存储是有序的，

可变参数：格式public static int adds(int...arr){} 修饰符 返回值类型 方法名（数据类型...变量名）{}
可以传递不确定数量的参数
注：（1）一个方法只能有一个可变参数，（2）如果方法参数有很多，那么可变参数必须写在参数列表末尾


Collections（集合工具类）常用方法：
（1）Collections.addAll()批量增加元素 Collections.addAll(list,"a","b","c","d");
（2）Collections.shuffle(list); 打乱顺序
（3）Collections.sort(list); 默认升序 
注：当排序的是自定义的对象时，需要在对象中重写compare方法（在对象中去实现Comparable<Person>接口）。
compareTo(Person o) 自己减去参数就是升序
第二种方法：Collections.sort(li, new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return o2.getAge() - o1.getAge();//当前时降序方法。
            }
        });


Map集合
Map集合中的元素，key是不允许重复的，value是允许重复的
1.HashMap<K,V>底层是哈希表 是一个无序集合，是多线程的集合，线程不安全
LinkedHashMap集合底层是哈希表+链表
LinkedHashMap集合是一个有序集合，存储元素和取出元素的顺序一致

2.map.put("a","1");
System.out.println(map.remove("a")) ;key
System.out.println(map.get("c"));
map.containsKey();

Set<String> set = map.keySet();//返回key值的集合
Set<Map.Entry<String,String>> set =  map.entrySet();//把键值对存储在集合之中

Hahstable 单线程



























