1.JVM：可以理解为翻译　win版JVM lin版JVM 　JRE包含JVM
2.JDK : Java程序开发的工具包 包含JRE 
3.编译后出现。class
4.命名规范：(1) 类名 HelloWorld
                   (2)变量名 helloWorld;
5.字符串不是基本类型，是引用类型。
6.变量在括号内才能使用。
7.long 必须是1000L。 float 必须是5.6F；
8.从小范围到大范围，自动进行转换（隐式）；强制类型转换：从大范围到小范围，（int）410L；
9.continue 跳过当次循环，继续执行下一次。
10.IDE集成开发环境
11.idea 快捷键： alt + 4 打开终端窗口
                          Alt + Enter 导入包，自动修正代码
                          Ctrl + Shift + / 选中代码注释。
                          Ctrl + v 删除光标所在行
                          Ctrl + d 复制光标所在行
                          Ctrl + Alt + L 格式化代码
12.任何数据类型在和字符串进行链接的时候，结果都会变成字符串。
13.定义方法： public static void 方法名(){
}
14. 10.fori 循环的简写
15.方法的重载，方法名相同，参数不相同。
16.动态初始化数组格式 int[] a = new int[100];
     静态初始化数组格式 int[] a = new int[]{1,2,3,4,5,6,7,8,9};
17.java内存： （1）栈（Stack）存放的是方法中的局部变量，方法的运行一定要在栈中；
                              局部变量： 方法的参数，或者是方法{}内部变量
                              作用域：一旦超出作用域，立刻从栈中消失
                      （2）堆（Heap）：凡是new出来的东西都在堆中。
                      （3）方法区（Method Area）：存放的class相关信息，包含方法信息。（成员方法的地址在方法区内？）
                      （4）本地方法区（Native Method Stack）与操作系统相关。
                      （5）与CPU相关
18.数组既可以作为方法的参数，也可以作为返回值。两者均为数组的地址。


----------------------------------------------------------------------------
----------------------------------------------------------------------------
----------------------------------------------------------------------------
----------------------------------------------------------------------------
1.面向过程：当需要实现一个功能的时候，每一个具体的步骤都要亲历亲为，详细处理每一个细节；
   面向对象：当需要实现一个功能的时候，不关心具体的步骤，而是找一个已经具有该功能的人（jar包？），来帮助实现。
2.面向对象思想，它可以将复杂的事情简单化，并将我们从执行者变成指挥者。面向对象是三大特征：封装（），继承，多态；
3.类与对象: 类是一种对事物的描述，是抽象的，
                  对象是对这种类的实例化，他是具体的，可以直接使用的；
4.类的组成：成员变量（属性）：成员变量直接定义在类中，在方法外
                   成员方法（行为）：成员方法不要写static 关键字；
5.类的使用 ：（1）导包 指出需要使用的类在什么位置。 格式 ： import 包名.类名
                    （2）创建 类名称 对象名 = new 类名称(); Student stu = new Student();
                      (3) 使用： 使用变量 使用方法 对象名.成员变量名 对象名.成员方法名（参数）
6.访问成员方法的时候，成员方法有自己的地址， 不随着变量名的改变而改变 a.call() 与 b.call()的地址一致。
7.对象类型既可以作为方法的参数，也可以作为返回值。两者均为数组的地址。
8.封装性在Java中的体现：
（1）方法就是一种封装
（2）关键字private也是一种封装
9.private：一旦使用private进行修饰，那么本类之中仍可以随意访问，但是，超出本类后无法进行直接访问。可以通过类中的方法进行间接访问。
在类中可以定义一些限制条件。
10.对呀基本数据类型中的boolean，Getter方法一定要写成isXxx的形式，而setXxx规则不变。
11.通过谁调用方法，谁就是this.
12.一个标准的类：（1）所有的成员变量都要使用private关键字修饰
                            （2）为每一个成员变量编写一对Getter Setter方法
                            （3）编写一个无参构造的方法
                            （4）编写一个全参构造方法
标准的类又叫做 JavaBean

===========================================
===========================================
===========================================
===========================================
1.API:应用程序编程接口， JDK提供的类的说明文档
2.Scanner 键盘输入 Scanner是个类，按照类的使用方法使用
3.ArrayList<E> 代表泛型，泛型只能是引用类型，不能是基本类型。
如果想存储基本类型，必须使用基本类型对应的“包装类”；
byte     Byte
short    Short
int        Integer
long     Long
float     Float
double Double
char     Character
boolean Boolean
4.对于ArrayList来说，直接打印得到的不是地址值，而是内容。ArrayList也可以作为返回值或是传参类型。
5.String底层是用的字节数组byte[]
6.字符串常量池：程序当中直接写上双引号字符串，就在字符串常量池中，

对于基本类型来说，==是进行数值的比较。
对于引用类型来说，==是进行【地址值】的比较。

7.equals:
public boolean equals(Object obj),参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true，否则返回false.
任何对象都可以用Object进行接收
注意：（1）推荐写法：System.out.println("abc".equals(c));

public boolean equalsIgnoreCase() 不区分大小写的比较

**注意equals与==**
**在Object中，==和equals没有区别**
如果this和obj指向的hi同一块内存对象，则返回true,如果this和obj指向的不是同一块内存，则返回false
**在String类中（对Object中的equals方法进行了重写）**
equals 方法比较的是对象的值
==比较的是地址（是否是同一个对象）



8.get:
public int length(), 获取字符串中字符的个数。
public String concat(String str),将当前的字符串与参数字符串拼接后成为返回新的字符串
public char charAt(int index) 获取指定索引位置的单个字符。
public int indexOf(String str),查找参数字符串在本字符串中首次出现的索引位置，如果没有返回-1.
9.截取：
public String substring(int index),截取从参数位置一直到字符串末尾，返回新的字符串。
public String substring(int begin，int end), 截取从begin开始，一直到end结束，中间的字符串。
，[begin,end）包含左边，不包含右边。
10。转换：
public char[] toCharArray(),将当前字符串拆分成字符串数组作为返回值。
public byte[] getBytes(),获取当前字符串底层的字节数组。
public String replace(CharSequence oldString, CharSequence newString),
将所有出现的老字符串替换成新的字符串，返回替换之后的结果新字符串。
11.分割：
public String[] split(String regex),按照参数规则，将字符串切分成为若干部分。
注意：
split方法的参数其实是一个“正则表达式”，如果按照英文句点“.”进行切分，必须先“\\.”

======================================
======================================
======================================
======================================
1.static关键字：
（1）一旦使用static关键字，那么这样的内容就不属于对象自己，而是属于类的，凡是本类的对象，都共享一份。
只要前面的赋值了，后面的就自动跟前面的一致。
（2）static 修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。
如果没有static关键字，那么必须首先创造对象，然后通过对象才能使用他。
如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用他。
注意：（1）推荐使用类名.静态方法来使用。
（2）对于本类之中的静态方法可以省略类名称。

（3）【静态只能直接访问静态，不能直接访问非静态。 静态成员方法不能直接访问非静态的变量。】
原因：因为在内存中是先有的静态内容，后有的非静态内容。后知道先，但先不知道后
静态方法中不能使用this关键字。

2.静态代码块的格式：
public class 类名称{
           static{
           //静态代码块的内容

       }
}
特点：当第一次使用到本类的时候，静态代码块执行唯一的一次。（随着类的创建而创建，随着类的消失而消失）
静态内容总是优先于非静态，静态代码块比构造方法先执行。
作用：
用来一次性地对静态成员变量进行赋值。

3.Arrays类中的两种方法：
Arrays.toString(int a[]) 返回值String
Arrays.sort(int a[]); 返回值void 从小到大排序

4.Math方法：
public static double obs(double num), 获取绝对值
public static double ceil(double num), 向上取整
public static double floor(double num), 向下取整
public static double long round(double num), 四舍五入


======================================
======================================
======================================
======================================
1.继承:
(1)继承主要解决的问题是：【共性抽取】。
父类，也称基类，超类
子类，也称派生类
父类的格式：
public class 父类名称{
 ......
}
子类的格式：
public class 子类名称 extends 父类名称{
 ......
} 
(2)在父子类的继承关系当中，如果【成员变量】重名，则创建子类对象时，访问有两种方式：
直接通过子类对象访问成员变量：
       等号左边是谁，就优先用谁，没有则向上寻找。
简接通过成员方法访问对象：
       该方法属于谁，就优先用谁，没有则向上找

(3)局部变量： 直接写成员变量名
本类中的成员变量： this.成员变量名
父类中的成员变量：super.成员变量名

(4)在父子类的继承关系当中，创建子类对象，访问【成员方法】的规则：
        创建的对象是谁，就优先用谁，如果没有则向上找
注意：无论是成员变量还是成员方法，如果没有都是向上找父类，绝对不会向下找子类。

(5)重写（Override）
概念：在继承关系中，方法的名称一样，参数列表也一样。
重写（Override）:方法的名称一样，参数列表【也一样】。覆盖，覆写
重写（Overload）:方法的名称一样，参数列表【不一样】
方法的覆盖重写的特点：创建的是子类对象，则优先用子类方法。
重写的注意事项：
①必须保证子类父类方法的名称一样，参数列表也一样。
@Override,写在方法前面，用来检测是不是有效的正确覆盖重写。
②子类方法的返回值必须小于等于父类方法的返回值范围。
Object是所有类的父类。
③子类方法的权限必须【大于等于】父类方法的权限修饰符。
权限修斯符：public>protected>(default)>private
备注：(default)不是关键字，而是什么都不写，留空 例如 int a. (留空，什么都不写)

(6)设计原则：对于已经投入使用的类，尽量不要进行修改，推荐定义一个新的类，来重复利用其中共性内容，
并且添加改动新内容。
spuer.show(); 把父类的原有方法拿过来重复利用。

(7)继承关系中，父子类构造方法的访问特点：
①子类构造方法当中有一个默认隐含的“super()”调用，因此，一定先调用父类构造，后执行子类构造。
②子类构造可以通过super关键字来调用父类重载构造。
③super的父类构造调用，必须是子类构造方法的第一个调用。不能一个子类构造调用多次super构造。
④子类必须调用父类构造方法，不写则赠送super,写了则用写的指定的super调用。super只能有一个，必须是
第一个语句

(8)super关键字的三种用法：
1.在子类的成员方法中，访问父类的成员变量。
2.在子类的成员方法中，访问父类的成员方法。
3.在子类的构造方法中，访问父类的构造方法。

(9)this关键字(用来访问本类内容)的三种用法：
1.在本类的成员方法中，访问本类的成员变量。
2.在子类的成员方法中，访问本类的另一个成员方法。
3.在本类的构造方法中，访问本类的另一个构造方法。注意：this(....)调用也必须是构造方法的第一个语句。唯一一个。
super和this两种构造调用，不能同时使用。

2.java语言是单向的，一个类的直接父类只有唯一一个。
java语言可以多级继承 ；class A{}      class B extends A{};   class C extends B{};
一个子类的直接父类是唯一的，但是一个父类可以拥有多个子类:
class A{}      class B extends A{};   class C extends A{};


======================================
抽象：
1.如果父类当中的方法不确定如何进行{}方法体实现，那么这就应该是个抽象方法。
抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。
抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract。
2.如何使用抽象类和抽象方法：
(1)不能直接new抽象类对象
(2)必需通过一个子类继承抽象父类。
(3)子类必须覆盖重写抽象父类中的所有抽象方法
覆盖重写(实现)：去掉抽象方法中的abstract关键字，补上方法体中的内容。
(4)创建子类对象进行使用。

3.抽象类中，可以用构造方法，是提供子类创建对象时，初始化父类成员使用的。
抽象类中，不一定包含抽象方法，但有抽象方法的类，必须是抽象类


======================================
接口:
1.接口就是一种公共的规范标准，只要符合规范标准，就可以大家通用。
2.(1)接口就是多个类的公共规范
(2)接口是一种引用数据类型，最重要的内容是其中的抽象方法。
(3)定义一个接口的格式
public interface 接口名称{
   //接口内容
}
注：换成关键字interface之后，编译生成的字节码文件仍然是，.java ---> .class;
如果是java7，那么接口中可以包含的内容有：
1.常量
2.抽象方法
java8:
3.默认方法
4.静态方法
java9:
5.私有方法

3.定义抽象方法：
public abstract 返回值类型 方法类型(参数列表)；
注意事项：
1.接口当中的抽象方法，修饰符必须是两个固定的关键字:public abstract
2.这两个关键字修饰符，可以选择性的省略。
3.方法三要素，可以随意定义。
public abstract void method();
abstract void method();
public void method();
void method();

4.使用方法：
(1)接口不能直接使用，必须有一个"实现类"来"实现该接口"。
格式：public class 实现类名称 implements 接口名称{
          //.....
}
(2)接口的实现类必须进行覆盖重写（实现）接口中的所有抽象方法。
(3)创建实现类的对象，进行使用。
注意事项：
如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。

5.定义默认方法：从Java8开始接口允许定义默认方法
格式 public default 返回值类型 方法名称(参数列表){
方法体
}
备注：接口当中的默认方法，可以解决接口升级问题
(1)default方法如果在实现类中没有，会向上找接口的。接口的默认方法，可以通过接口实现类对象直接调用。
(2)接口默认方法，也可以被接口实现类进行覆盖重写

特：【抽象类有利于代码复用，接口有利于代码维护】。

6.定义静态方法：从Java8开始接口允许定义静态方法
格式 public static 返回值类型 方法名称(参数列表){
方法体
}
注意：【不能通过接口实现类的对象来调用接口中的静态方法。】
使用方法：接口名称.静态方法名称(参数)

7.定义私有方法：我们需要抽取一个公有方法，来解决两个默认方法之间重复代码的问题。
但是这个公有方法不应该让实现类使用，应该私有化。
解决方法：从Java9开始接口允许定义私有方法。
(1)普通私有方法，解决多个默认方法之间重复代码问题
格式：
private 返回值类型 方法名称(参数列表){
            方法体
}
(2)静态私有方法，解决多个静态方法之间重复代码问题
格式：
private static 返回值类型 方法名称(参数列表){
            方法体
}

8.接口中的成员变量
必须使用public static final三个关键字进行修饰
从效果上看，这其实是接口的常量。
格式:
public static final 数据类型 常量名称 = 数据值;
一旦使用final关键字进行修饰，说明不可改变。
(1)接口中的常量，可以省略public static final，但是不写依旧默认存在
(2)接口中的常量，必须进行赋值，不能不赋值。
(3)接口中的常量,使用完全大写的字母，用下划线进行分隔。

9.总结:
(1)接口是没有静态代码块或者构造方法的。
(2)一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
格式
public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB{
           //覆盖重写所有抽象方法
}
(3)如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。
(4)如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。
(5)如果实现类所实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的实现方法进行覆盖重写。
(6)一个类中如果直接父类当中的方法，和接口中的默认方法产生了冲突，优先使用父类中的方法。

10.(1)类与类之间是单继承的，直接父类只有一个
(2)类与接口之间是多实现的，一个类可以实现多个接口
(3)接口与接口之间是多继承的；
注意：
(1)多个父接口当中的抽象方法可以重复
(2)多个父接口当中的默认方法不可以重复，子接口必须进行覆盖重写，而且要带default关键字。


多态:
extends继承或者implements实现，是多态的前提。一个对象拥有了多个形态，这就是对象的多态性
1.代码中的多态性体现，父类引用指向子类对象。
格式:
父类名称 对象名 = new 子类名称();
或者:
接口名称 对象名 = new 实现类名称();
2.访问成员变量和成员方法的规则和之前一致。
成员变量：编译看左边。运行还看左边；
成员方法：编译看左边。运行看右边； ==调用时会使用子类中重写的方法==
3.使用多态的好处：无论右边new地时候换成那个子类对象，等号左边的调用方法都不会变化。

4.（1）对象的向上转型，其实就是多态的写法：
格式：父类名称 对象名 = new 子类名称();
含义：右侧创建一个子类对象，把它当作父类来使用。
注意事项：向上转型一定是安全的，但是对象一旦向上转移为父类，那么就无法调用子类原本特有的内容。(比父类多的部分，比如成员变量或者方法)，
（2）对象的向下转型
格式：子类名称 对象名 = （子类名称）父类对象；
含义：将父类对象，还原成原本的子类对象；

5.对象 instanceof 类名称
返回一个Boolean值，也就是判断前面对象能不能当作后面类型的实例。


======================================
final 关键字：
final关键字代表最终的，不可改变的。
常用四种方法：
1.可以用来修饰一个类
2.可以用来修饰一个方法
3.可以用来修饰一个局部变量
4.可以用来修饰一个成员变量

1.当final关键字修饰一个类的时候，格式：
public final class 类名称{
        //.....    
}
含义：当前这个类不能有任何子类
注意：一个类如果是final的，那么其中的所有成员方法都无法覆盖重写

2.当final关键字修饰一个方法的时候，这个方法就是最终方法，不可被覆盖重写。
格式：
修饰符 final 返回值类型 方法名称（参数列表）{
          //方法体
}
注意事项：对于类和方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。

3.当final修饰一个局部变量时，
对于基本数据来说，不可改变说的是变量中的数据不可改变
对于引用数据来说，不可改变说的是变量中的地址值不可变

4.当final关键字修饰成员变量时候：
（1）由于成员变量具有默认值，所有用了final关键字后必须手动赋值，不会再给默认值。
（2）对于final的成员变量，要么直接赋值，要么通过构造方法进行赋值
（3）必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值

===========================================

1.权限修斯符： public>protected>(default)>private  （成员变量的访问） //本类的子类
同一个类          √              √                 √              √                
同一个包          √              √                 √              ×           
不同包子类       √              √                 ×              ×            
不同包非子类    √              ×                 ×              ×               

2.内部类：如果一个事务的内部包含另一个事务，那么这就是一个类内部包含另一个类
分类：（1）成员内部类 （2）局部内部类（包含匿名内部类）

3.（1）成员内部类的格式：
修饰符 class 外部类名称 {
      修饰符 class 内部类名称{
            //.....
     }
        //.......
}
注意事项：内用外，随意访问。外用内，一定要借助内部对象。

（2）使用成员内部类
1.间接在外部类的方法当中，使用内部类，然后main只是调用外部类方法。
2.直接方式：
类名称 对象名 = new 类名称()；
【外部类名称.内部类名称 = new 外部类名称().new内部类名称();】

4.如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名

5**.如果一个类定义在一个方法内部的，那么这就是局部内部类**
只有当前所属的方法才能使用它，出了这个方法外面就不能使用了
定义格式：
修饰符 class 外部类名称{
       修饰符 返回值类型 外部类方法名称（参数列表）{
              class 局部内部类名称{
                       //......
              }       
      }
}

6.定义一个类的时候，权限修饰符规则：
（1）外部类：public/（default）
（2）成员内部类：public/ protected/（default）/private
（3）局部内部类：什么都不能写

7.局部内部类：如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final】.
备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。
原因：（1）new出来的对象在堆内存中，
（2）局部变量是跟着方法走的，在栈内存当中。
（3）方法运行结束之后，立刻出栈，局部变量就会立即消失；
（4）但是new出来的对象会在堆中持续存在，直到垃圾回收消失

8.匿名内部类
如果接口实现类（或者是父类的子类），只需要使用唯一的一次，
那么这种情况下就可以省略该类的定义，而改为使用【匿名内部类】
（1）格式：
接口名称 对象名 = new 接口名称(){
              //覆盖重写所有抽象方法
}；
（2）注意事项：
匿名内部类：在【创建对象】的时候，只能使用唯一一次。
匿名对象，在【调用方法的时候】，只能调用唯一的一次
匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】
注意：匿名内部类和匿名对象不是一回事

9.（1）接口作为成员变量类型
（2）接口作为方法的参数和返回值


